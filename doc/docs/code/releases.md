# Начальная база данных и начальный образ базы

В конфигурации есть разделение между начальной базой и начальным образом. Начальная база лежит в основе формирования дистрибутива конфигурация, т.е. эта та база, которую пользователь добавляет в список информационных баз в диалоге запуска программы.

Начальный образ - это xml-файл выгрузки начальной базы при помощи конфигурации Конвертация данных 2. Начальный образ нужен для подготовки новой области данных в составе той же информационной базы. Начальный образ не полностью соответствует по набору данных начальной базе. Из начального образа исключаются неразделенные данные и данные по группам пользователей.

# Поддержка актуальности регламентированной отчетности

Начальная база должна поддерживаться в актуальном состоянии, это касается как структуры метаданных, так и регламентированной отчетности, которая является внешней по отношению к конфигурации, подсистемой. Подготовка обновления регламентированной отчетности для нового релиза состоит из следующих этапов:

1. Убеждаемся, что вся новая рег.отчетность уже находится в тестере по пути: `InitialDatabase.RegulatoryReports`
2. Отчеты, которые нужно удалить при обновлении (если таковые имеются), нужно перенести в папку `InitialDatabase.RegulatoryReports.Old`
3. Готовим архив обновления путем создания и запуска специального теста (`Tools.PrepareRR`), пример:


		p = Call ( "Tools.BuildPackage.Params" );
		// Релиз, для которого делается обновление
		p.Release = "5_0_8_7";
		// Пусть к папке, куда тестер выгрузить архив обновленной рег.отчетности
		p.Path = "D:\";
		list = p.Remove;
		list.Add ( "IPC18" ); // идентификатор удаляемого отчета
		list = p.Update;
		// Полный путь к обновляемому/добавляемому отчету
		// (если отчет не будет найден, он будет добавлен)
		list.Add ( "InitialDatabase.RegulatoryReports.Month.IPC18_042019" );
		// Вызов скрипта подготовки пакета
		Call ( "Tools.BuildPackage.Build", p );


4. Полученный архив необходимо добавить в как бинарный шаблон в обработку `UpdateInfobase`, имя шаблона должно иметь префикс `Reports`, например так: `Reports_5_0_8_7`

В модуле обработки `UpdateInfobase`, в ответственную за релиз процедуру, нужно добавить вызов метода `updateReports ()`, например так:

	Procedure _5_0_8_7 () export
		
		BeginTransaction ();
		for each tenant in Tenants do
			activateTenant ( tenant );
			setLogins ( DF.Pick ( tenant, "Code" ) );
			fillMembership ( tenant );
			updateReports ();
		enddo;
		CommitTransaction ();	
		
	EndProcedure

Таким образом, наша конфигурация теперь содержит пакет обновления регламентированной отчетности, что будет важно для подготовки начального образа.

# Схема подготовки начального образа

1. Обновляем начальную базу последним релизом конфигурации и запускаем её в режиме предприятие. Таким образом, мы гарантируем, что в начальной базе обновлены настройки и регламентированная отчетность. В качестве начальной базы для нового релиза можно брать начальную базу предыдущего релиза.
2. Выгружаем схему данных (с включенным флагом `ВыгружатьДвиженияДокументов`, в обработке `MD83Exp.epf`) в файл
3. Загружаем схему в конвертацию данных и создаем новую конвертацию
4. При создании, создаем все правила автоматически, создаем правила выгрузки автоматически и для всех объектов (правила для выгрузки набора констант - не создаем)
5. Вносим следующий код в обработчики конвертации данных:

**Перед выгрузкой данных**

	r = InformationRegisters.ReportFields.CreateRecordset ();
	r.Write ();
	r = InformationRegisters.FieldsDependency.CreateRecordset ();
	r.Write ();

**Перед выгрузкой объекта**

	m = Metadata.FindByType ( Правило.ОбъектВыборки );
	if ( m = Metadata.InformationRegisters.Membership
		or m = Metadata.Catalogs.Employees
		or m = Metadata.Catalogs.Individuals
		) then
		Отказ = true;
	elsif ( m = Metadata.Catalogs.Users ) then
		name = "" + Правило.ОбъектВыборки;
		if ( name = "Администратор"
			or name = "Administrator" ) then
		else
			Отказ = true;
		endif;
	else
		Отказ = ( Metadata.CommonAttributes.Tenant.Content.Find ( m ).Use = Metadata.ObjectProperties.CommonAttributeUse.DontUse );
	endif;

**Перед конвертацией объекта**

	// I do not load logins because it can have conflicts with
	// existed logins by tenants access property (existed login could have
	// only 1 tenant in the list)

	type = TypeOf ( Источник );
	if ( type = Type ( "CatalogRef.Logins" )
		or type = Type ( "CatalogRef.Employees" )
		or type = Type ( "CatalogRef.Individuals" )
		) then
		Отказ = true;
	elsif ( type = Type ( "CatalogRef.Users" ) ) then
		name = "" + Источник;
		if ( name = "Администратор"
			or name = "Administrator" ) then
		else
			Отказ = true;
		endif;
	endif;

**После выгрузки данных**

	list = new Array ();
	tenantContent = Metadata.CommonAttributes.Tenant.Content;
	dontUse = Metadata.ObjectProperties.CommonAttributeUse.DontUse;
	for each constant in Metadata.Constants do
		if ( tenantContent.Find ( constant ).Use = dontUse ) then
			continue;
		endif;
		name = constant.Name;
		value = ValueToStringInternal ( Constants [ name ].Get () );
		list.Add ( new Structure ( "Name, Value", name, value ) );
	enddo;
	ПередатьОдинПараметрВПриемник ( "Constants", ValueToStringInternal ( list ) );

**После загрузки данных**

	list = ValueFromStringInternal ( Параметры.Constants );
	for each item in list do
		name = item.Name;
		value = ValueFromStringInternal ( item.Value );
		Constants [ name ].Set ( value );
	enddo;

6. Сохраняем файл для обмена в файл
7. Запускаем начальную базу и обработкой `V8Exchan83.epf` производим выгрузку данных в xml-файл
8. Переключаемся в среду разработки конфигурации и загружаем файл (как есть) в макет `Init` обработки `CreateTenant`

# Сборка релиза

1. После того, как была обновлена регламентированная отчетность и начальный образ, необходимо провести обновление начальной и демонстрационной баз. При этом, после обновления, эти базы нужно запустить на выполнение, чтобы в них отработали процедуры перехода на новый релиз.

!!!note "Примечание"
	Если новый релиз не содержит процедур обновления данных, регламентированной отчетности, изменений в структуре метаданных и новых начальных данных (констант), п.1 можно пропустить

2. Подготовленные dt-файлы, стандартно, через конфигуратор, загружаются на сервер в одноименные информационные базы (если были изменения в п.1).
3. Локально, на компьютере разработчика, формируется cf-файл с обновлением и выгружается на сервер в специальную папку. Путь к файлу задается в параметре `File` структуры параметров `Tools.BuildRelease.Params`. Например, путь может быть таким `d:\5.0.10.1\1cv8.cf`
4. Конфигурационный файл загружается в edt и сливается с master-веткой.
5. Корректируется тест `Tools.PrepareRelease` в котором указываются параметры релиза, признак промежуточности, поддерживаемая версия платформы, список релизов на основании которых будет формироваться cfu-файл и другие параметры.
6. Для обновления [приложения](/customization#objectNames) в справке по соответствию идентификаторов объектов и их имен, запускаем обработку MetadataObjectsForAttachments1 и сохраняем объекты в структуре сайта. Перестраиваем и выгружаем сайт.
7. Все изменения выгружаем на gitlab в мастер ветку, после этого система запускает тестирование, сборку релиза, выгрузки сформированных обновлений и дистрибутивов на ftp-сервера и сервер лицензий.
